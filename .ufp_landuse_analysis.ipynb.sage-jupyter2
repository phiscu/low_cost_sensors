{"attachments":{"clipboard16.png":{"type":"sha1","value":"98e11006da36100cf5755d08dd254bef3ed620e4"}},"cell_type":"markdown","id":"939c7d","input":"## Long data format        <img src=\"https://www.joyofdata.de/blog/wp-content/uploads/2012/11/Clipboard16.png\" style=\"max-width:100%\">\n\nDie Daten befinden sich momentan noch im sogenannten long data format. Wir werden sie in diesem weiterverarbeiten und anschließend in das wide data format umwandeln. Zum Unterschieden [hier](https://www.theanalysisfactor.com/wide-and-long-data/) noch eine kurze Erläuterung.","pos":3,"state":"done","type":"cell"}
{"backend_state":"running","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":85217280},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.9"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"efcf37","input":"predictor = 'Bebaut'","pos":24,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":0,"id":"fbbc60","input":"","pos":41,"state":"done","type":"cell"}
{"cell_type":"code","id":"08da55","input":"data_ufp = data_ufp.drop_duplicates()\nprint(data_ufp.sort_values(['trackpoint']).head())","pos":10,"state":"done","type":"cell"}
{"cell_type":"code","id":"1a428e","input":"X = data_wide.loc[:, predictor].values.reshape(-1, 1)\nY = data_wide.loc[:, 'ufp'].values.reshape(-1, 1)","pos":26,"state":"done","type":"cell"}
{"cell_type":"code","id":"3131b0","input":"data_wide = pd.merge(data_wide, data_ufp, on = 'trackpoint')\nprint(data_wide.head())","pos":16,"state":"done","type":"cell"}
{"cell_type":"code","id":"35de5e","input":"data_grouped = data_landuse.groupby(['area_type', 'trackpoint'], as_index=False).sum()\nprint(data_grouped.head())","pos":12,"state":"done","type":"cell"}
{"cell_type":"code","id":"38bf66","input":"linear_regressor.fit(X, Y)\nY_pred = linear_regressor.predict(X)","pos":30,"state":"done","type":"cell"}
{"cell_type":"code","id":"5b8045","input":"print(data_wide.columns)","pos":22,"state":"done","type":"cell"}
{"cell_type":"code","id":"691dcb","input":"X = data_wide[gruenblau].sum(axis=1).values.reshape(-1, 1)\nY = data_wide.iloc[:, 6].values.reshape(-1, 1)\nlinear_regressor = LinearRegression()\nlinear_regressor.fit(X, Y)\nY_pred = linear_regressor.predict(X)\n\nplt.scatter(X, Y)\nplt.plot(X, Y_pred, color='red')\nplt.xlabel('GruenBlau-Anteil 250m um den Messpunkt [%]')\nplt.ylabel('UFP-Konzentration [#/cm^3]')\nplt.show()\n\nprint('------ Lineare Regression -----')\nprint('Funktion: y = %.3f * x + %.3f' % (linear_regressor.coef_[0], linear_regressor.intercept_))\nprint(\"R² Score: {:.2f}\".format(linear_regressor.score(X, Y)))\nprint(\"\\n\")\n\nX = data_wide[graubraun].sum(axis=1).values.reshape(-1, 1)\nY = data_wide.iloc[:, 6].values.reshape(-1, 1)\nlinear_regressor = LinearRegression()\nlinear_regressor.fit(X, Y)\nY_pred = linear_regressor.predict(X)\nplt.scatter(X, Y)\nplt.plot(X, Y_pred, color='red')\nplt.xlabel('GrauBraun-Anteil 250m um den Messpunkt [%]')\nplt.ylabel('UFP-Konzentration [#/cm^3]')\nplt.show()\n\nprint('------ Lineare Regression -----')\nprint('Funktion: y = %.3f * x + %.3f' % (linear_regressor.coef_[0], linear_regressor.intercept_))\nprint(\"R² Score: {:.2f}\".format(linear_regressor.score(X, Y)))\nprint(\"\\n\")","pos":38,"state":"done","type":"cell"}
{"cell_type":"code","id":"694f79","input":"data_landuse = data[['area_type', 'trackpoint', 'type_percentage']]\nprint(data_landuse.sort_values(['trackpoint']).head())\n","pos":8,"state":"done","type":"cell"}
{"cell_type":"code","id":"69b082","input":"import pandas as pd\nimport numpy as np\n\npath = \"your_qgis_output.csv\"\n\ndata = pd.read_csv(path, sep = \",\")\nprint(data.head())","pos":2,"state":"done","type":"cell"}
{"cell_type":"code","id":"851867","input":"data_wide = data_wide.fillna(0)\nprint(data_wide.head())","pos":18,"state":"done","type":"cell"}
{"cell_type":"code","id":"8a18d5","input":"linear_regressor = LinearRegression()","pos":28,"state":"done","type":"cell"}
{"cell_type":"code","id":"90494d","input":"print('------ Lineare Regression -----')\nprint('Funktion: y = %.3f * x + %.3f' % (linear_regressor.coef_[0], linear_regressor.intercept_))\nprint(\"R² Score: {:.2f}\".format(linear_regressor.score(X, Y)))\nprint(\"\\n\")","pos":34,"state":"done","type":"cell"}
{"cell_type":"code","id":"904d45","input":"plt.scatter(X, Y)\nplt.plot(X, Y_pred, color='red')\nplt.xlabel(str('Anteil des Flaechentyps' + predictor + '250m um den Messpunkt [%]'))\nplt.ylabel('UFP-Konzentration [#/cm^3]')\nplt.show()","pos":32,"state":"done","type":"cell"}
{"cell_type":"code","id":"a4e28a","input":"data.columns = ['trackpoint', 'ufp', 'area_type', 'type_percentage']\nprint(data.head())","pos":5,"state":"done","type":"cell"}
{"cell_type":"code","id":"c95bb0","input":"print(data_wide.columns)\ngruenblau = ['Gruen_ohne_Baeume', 'Gewaesser', 'Gruen_mit_Baeumen']\ngraubraun = ['Bebaut', 'Bebaut_ohne_Gebaeude']","pos":36,"state":"done","type":"cell"}
{"cell_type":"code","id":"de1fa7","input":"data_wide = data_grouped.pivot(index = 'trackpoint', columns = 'area_type', values = 'type_percentage')\nprint(data_wide.head())","pos":14,"state":"done","type":"cell"}
{"cell_type":"code","id":"e54b20","input":"import matplotlib.pyplot as plt\nfrom sklearn.linear_model import LinearRegression","pos":20,"state":"done","type":"cell"}
{"cell_type":"code","id":"f4948c","input":"data_ufp = data[['trackpoint', 'ufp']]\nprint(data_ufp.sort_values(['trackpoint']).head())\n","pos":7,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"01b05f","input":"Zunächst benennen wir die Spalten neu, um Missverständnisse zu vermeiden. **Solltet ihr von meiner Reihenfolge und Benennung aus der Videoanleitung abgewichen sein, passt die Benennung hier bitte an.**","pos":4,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"10984c","input":"Den Datensatz `data_ufp` reduzieren wir nun wieder auf eine Zeile pro Trackpoint.","pos":9,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"400478","input":"Da einige Flächentypen nicht in allen Buffern vertreten sind, haben wir noch recht viele `NaN`-Values. Wir ersetzen diese durch den Flächenanteil 0.","pos":17,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"413967","input":"Nun trainieren wir unsere lineare Regression (`.fit`) und speichern alle Informationen über unseren Regressor (oder \"Predictor\") in der Variable `Y_pred`.","pos":29,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"486bc2","input":"\nDa sich die Messdaten nachwievor nur auf einen Trackpoint beziehen, die anderen Daten aber auf die Teilpolygone der Buffer-Intersekte trennen wir den Datensatz in zwei Teile (`data_ufp` und `data_landuse`).","pos":6,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"49ec11","input":"Der Plot gibt uns eine Ahnung von der Verteilung der Messwerte und der Richtung und Stärke des Zusammenhangs. Wir erhalten aber keine Informationen über die Güte des linearen Modells. Darum lassen wir uns die `Funktion` des Modells und den Wert `R²` ausgeben. Letzterer gibt uns ein Maß für die Stärke des Zusammenhangs von X und Y.","pos":33,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"4e3a17","input":"# Datenanalyse von Mess- und Flächennutzungsdaten             <img src=\"https://www.btelligent.com/fileadmin/_processed_/7/0/csm_data-science-ansatz_2350412d17.jpg\" style=\"max-width:20%\">\n","pos":0,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"720500","input":"Was sehen wir hier? Die Korrelation der beiden Größen ist verschwindend gering. Der Anteil bebauter Fläche ist also eine denkbar ungeeignete Größe, um die Ultrafeinstaubkonzentration entlang der Fahrradroute zu erklären. Dies kann eine Vielzahl von Gründen haben. So ist natürlich zum einen sehr wahrscheinlich, dass schlicht ein sehr geringer Zusammehang besteht. Es gibt aber auch viele methodische Ursachen die eine Rolle spielen können.\nEine Möglichkeit wäre, dass wir unsere Kategorien zu kleinteilig gewählt haben. Wir fassen deshalb einfach mal alle Flächentypen in grün-blaue und grau-braune Infrastruktur zusammen.","pos":35,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"7a18df","input":"Nun wiederholen wir den gesamten Ablauf mit diesen neuen Kategorien.","pos":37,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"85f020","input":"Der gemessene Ultrafeinstaubwert (`'ufp'`) wird also jeweils unsere abhängige Variable (oder \"Predictand\", `Y`) sein, die Flächentypen jeweils die unabhängige Variable (oder \"Predictor\", `X`). Da wir verschiedene Flächentypen betrachten wollen, schaffen wir hierfür eine separate Variable (`predictor`) und müssen im Anschluss noch nur diese ändern, um uns weitere Analysen ausgeben zu lassen. Zunächst nehmen wir dafür jetzt mal den Flächentyp `'Bebaut'`.","pos":23,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"948c9e","input":"Zunächst müssen wir die zu untersuchenden Spalten in NumPy-Arrays umwandeln. ","pos":25,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"948da2","input":"Im nächsten Schritt instanzieren wir die Datenklasse `LinearRegression`, welche für nachfolgenden Funktionen gebraucht wird.","pos":27,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"9c2f5c","input":"","pos":40,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"a33b5c","input":"Da nun auch hier nur noch eine Zeile pro Messpunkt vorliegt. Können wir den Datensatz wieder mit den Messdaten vereinen. Hierbei dient die Spalte `trackpoint` als Schlüssel zur Zuordnung.","pos":15,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"a6c874","input":"Den Datensatz `data_landuse` fassen wir jetzt so zusammen, dass Teilpolygone des gleichen Flächentyps (z.B. `Bebaut`) im selben Buffer addiert werden. Somit existiert jetzt pro Flächentyp und Messpunkt nur noch eine Zeile.","pos":11,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"aa2741","input":"Zunächst lassen wir uns das Ergebnis in einem Scatterplot mit der Regressionsgeraden anzeigen. Vereinfacht kann man sagen, die Regressionsgerade beschreibt die lineare Funktion (`Y = a*X + b`), mit der sich die Ultrafeinstaubkonzentration mittels des Anteils bebauter Fläche im Umkreis von 250m um den Messpunkt vorhersagen lässt.","pos":31,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ab680a","input":"Auch hier geht die Korrelation gegen 0. Die Güte des Modells ist also sehr gering. Dennoch kann man zumindest erkennen, dass die UFP-Konzentration mit größerem Anteil unversiegelter Flächen eher sinkt. Spielt noch ein Bisschen herum und probiert die anderen Flächentypen aus.\nWelche Zusammenhänge hättet ihr nach einer kurzen Recherche zu Ultrafeinstaubemissionen erwartet? Welche inhaltlichen und methodischen Ursachen kann es für dieses Ergebnis geben? Bedenkt dabei sowohl Art und Ursprung der Eingangsdaten, als auch gewählte Parameter während des Verarbeitungsprozesses und nicht beachtete potentielle Einflussgrößen. Wo ist Verbesserungspotential und welche weiteren Daten würdet ihr hinzuziehen?","pos":39,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"b3e4f7","input":"Zunächst importieren wir wieder die nötigen Pakete, definieren unseren Pfad (bzw. den Dateinnamen im Cocalc-Projektordner) und laden die CSV-Datei als Pandas-Dataframe.","pos":1,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"cbe054","input":"## Wide data format             <img src=\"https://www.joyofdata.de/blog/wp-content/uploads/2012/11/Clipboard16.png\" style=\"max-width:100%\">\n\nMit dem Befehl `pandasDataFrame.pivot()` wandeln wir den Datensatz `data_landuse` nun in das wide data format um. Der jeweilige Messpunkt dient dabei als `Index` (Reihenbezeichnung) und die Flächentypen erhalten jeweils eine Spalte (`columns`) mit Flächenanteilen (`values`).","pos":13,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"d245f7","input":"## Analysen            <img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/0/05/Scikit_learn_logo_small.svg/200px-Scikit_learn_logo_small.svg.png\" style=\"max-width:100%\">\nIn diesem Dataframe liegen nun alle Informationen vor, wie wir sie brauchen. Wir können also damit beginnen den Datensatz näher zu analysieren und Hypothesen zu untersuchen. Die folgenden Zeilen zeigen euch, wie ihr in Python mit den Paketen `scikit-learn` und `matplotlib` eine lineare Regression durchführt. Ihr könnt hier aber auch bereits gelerntes aus der letzten Sitzung anwenden und den Datensatz auf weitere Hypothesen untersuchen.\n\n**Beachte:** *Es handelt sich hier nicht um einen aufgehübschten Beispieldatensatz sondern um echte Messdaten, wie sie viele von euch auch erhalten werden. Wenn eure Plots also nicht aussehen wie aus dem Lehrbuch und auch die Statistiken eher enttäuschen seid ihr vermutlich auf dem richtigen Weg ;)*","pos":19,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"e6b79e","input":"Ein Blick auf die Spaltennamen gibt uns einen Überblick, welche Variablen wir miteinander vergleichen können.","pos":21,"state":"done","type":"cell"}
{"id":0,"time":1603808609176,"type":"user"}
{"last_load":1600343130085,"type":"file"}